// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"
	"time"
)

const findAllInPeriodInclusive = `-- name: FindAllInPeriodInclusive :many
SELECT bd.id, bd.time
FROM booking_date bd
WHERE bd.time >= ? AND bd.time <= ?
`

type FindAllInPeriodInclusiveParams struct {
	Time   time.Time
	Time_2 time.Time
}

func (q *Queries) FindAllInPeriodInclusive(ctx context.Context, arg FindAllInPeriodInclusiveParams) ([]BookingDate, error) {
	rows, err := q.db.QueryContext(ctx, findAllInPeriodInclusive, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingDate
	for rows.Next() {
		var i BookingDate
		if err := rows.Scan(&i.ID, &i.Time); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByUUID = `-- name: GetCustomerByUUID :one
SELECT c.id, c.uuid, c.username
FROM customer c
WHERE c.uuid = ?
`

func (q *Queries) GetCustomerByUUID(ctx context.Context, uuid interface{}) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByUUID, uuid)
	var i Customer
	err := row.Scan(&i.ID, &i.Uuid, &i.Username)
	return i, err
}

const getVehicleByUUID = `-- name: GetVehicleByUUID :one
SELECT 
    v.id, 
    v.uuid, 
    v.registration_number, 
    v.make, 
    v.model, 
    v.fuel_type, 
    vc.id, 
    vc.category, 
    vc.price_per_day 
FROM vehicle v
    JOIN vehicle_category vc on v.category_id = vc.id
WHERE v.uuid = ?
`

type GetVehicleByUUIDRow struct {
	ID                 interface{}
	Uuid               interface{}
	RegistrationNumber string
	Make               string
	Model              string
	FuelType           string
	ID_2               interface{}
	Category           string
	PricePerDay        float64
}

func (q *Queries) GetVehicleByUUID(ctx context.Context, uuid interface{}) (GetVehicleByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVehicleByUUID, uuid)
	var i GetVehicleByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.RegistrationNumber,
		&i.Make,
		&i.Model,
		&i.FuelType,
		&i.ID_2,
		&i.Category,
		&i.PricePerDay,
	)
	return i, err
}

const insertNewBooking = `-- name: InsertNewBooking :exec
INSERT INTO booking(uuid, vehicle_id, customer_id)
VALUES (?, ?, ?)
`

type InsertNewBookingParams struct {
	Uuid       interface{}
	VehicleID  int64
	CustomerID int64
}

func (q *Queries) InsertNewBooking(ctx context.Context, arg InsertNewBookingParams) error {
	_, err := q.db.ExecContext(ctx, insertNewBooking, arg.Uuid, arg.VehicleID, arg.CustomerID)
	return err
}

const saveNewBookingDate = `-- name: SaveNewBookingDate :exec
INSERT INTO booking_date(time)
VALUES (?)
`

func (q *Queries) SaveNewBookingDate(ctx context.Context, argTime time.Time) error {
	_, err := q.db.ExecContext(ctx, saveNewBookingDate, argTime)
	return err
}

const selectAllBookings = `-- name: SelectAllBookings :many
SELECT b.id, b.uuid, b.vehicle_id, b.customer_id 
FROM booking b
`

func (q *Queries) SelectAllBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, selectAllBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.VehicleID,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBookingDatesByBookingID = `-- name: SelectBookingDatesByBookingID :one
SELECT bd.id, bd.time
FROM booking_date bd
WHERE bd.id = ?
`

func (q *Queries) SelectBookingDatesByBookingID(ctx context.Context, id interface{}) (BookingDate, error) {
	row := q.db.QueryRowContext(ctx, selectBookingDatesByBookingID, id)
	var i BookingDate
	err := row.Scan(&i.ID, &i.Time)
	return i, err
}

const selectBookingsByVehicleID = `-- name: SelectBookingsByVehicleID :many
SELECT b.id, b.uuid, c.uuid, c.username
FROM booking b
    JOIN customer c on b.customer_id = c.id
WHERE b.vehicle_id = ?
`

type SelectBookingsByVehicleIDRow struct {
	ID       interface{}
	Uuid     interface{}
	Uuid_2   interface{}
	Username string
}

func (q *Queries) SelectBookingsByVehicleID(ctx context.Context, vehicleID int64) ([]SelectBookingsByVehicleIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectBookingsByVehicleID, vehicleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectBookingsByVehicleIDRow
	for rows.Next() {
		var i SelectBookingsByVehicleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Uuid_2,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vehicleHasBookedDatesOnPeriod = `-- name: VehicleHasBookedDatesOnPeriod :one
SELECT EXISTS(
    SELECT 1 
    FROM booking b
        JOIN vehicle v on b.vehicle_id = v.id
        JOIN bookings_bookingdates bb on bb.booking_id = b.id
        JOIN booking_date bd on bb.bookingdate_id = bd.id
    WHERE v.uuid = ? AND bd.time >= ? and bd.time <= ?
)
`

type VehicleHasBookedDatesOnPeriodParams struct {
	Uuid   interface{}
	Time   time.Time
	Time_2 time.Time
}

func (q *Queries) VehicleHasBookedDatesOnPeriod(ctx context.Context, arg VehicleHasBookedDatesOnPeriodParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, vehicleHasBookedDatesOnPeriod, arg.Uuid, arg.Time, arg.Time_2)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
